package org.audit.services;

import org.audit.dto.VulnerabilityDTO;
import org.audit.dto.Severity;
import org.audit.dto.Status;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.logging.Logger;

@Service
public class VulnerabilityService implements IVulnerabilityService {

    private static final Logger logger = Logger.getLogger(VulnerabilityService.class.getName());

    @Value("${backend.url.vulnerabilities}")
    private String backendUrl; // URL-ul pentru endpoint-urile backend-ului

    private final RestTemplate restTemplate;

    public VulnerabilityService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @Override
    public VulnerabilityDTO addVulnerability(VulnerabilityDTO vulnerability) {
        logger.info("Adding new vulnerability");
        HttpHeaders headers = generateHeaders();
        HttpEntity<VulnerabilityDTO> entity = new HttpEntity<>(vulnerability, headers);

        VulnerabilityDTO savedVulnerability = restTemplate.exchange(
                backendUrl,
                HttpMethod.POST,
                entity,
                VulnerabilityDTO.class
        ).getBody();

        logger.info("Saved vulnerability: " + savedVulnerability);
        return savedVulnerability;
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByProject(Integer projectId) {
        logger.info("Fetching vulnerabilities for project ID: " + projectId);
        HttpHeaders headers = generateHeaders();
        HttpEntity<String> entity = new HttpEntity<>(headers);

        VulnerabilityDTO[] vulnerabilities = restTemplate.exchange(
                backendUrl + "/project/" + projectId,
                HttpMethod.GET,
                entity,
                VulnerabilityDTO[].class
        ).getBody();

        return List.of(vulnerabilities);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByProjectAndSeverity(Integer projectId, Severity severity) {
        logger.info("Fetching vulnerabilities for project ID: " + projectId + " with severity: " + severity);
        HttpHeaders headers = generateHeaders();
        HttpEntity<String> entity = new HttpEntity<>(headers);

        VulnerabilityDTO[] vulnerabilities = restTemplate.exchange(
                backendUrl + "/project/" + projectId + "/severity/" + severity.name(),
                HttpMethod.GET,
                entity,
                VulnerabilityDTO[].class
        ).getBody();

        return List.of(vulnerabilities);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByProjectAndStatus(Integer projectId, Status status) {
        logger.info("Fetching vulnerabilities for project ID: " + projectId + " with status: " + status);
        HttpHeaders headers = generateHeaders();
        HttpEntity<String> entity = new HttpEntity<>(headers);

        VulnerabilityDTO[] vulnerabilities = restTemplate.exchange(
                backendUrl + "/project/" + projectId + "/status/" + status.name(),
                HttpMethod.GET,
                entity,
                VulnerabilityDTO[].class
        ).getBody();

        return List.of(vulnerabilities);
    }

    @Override
    public List<VulnerabilityDTO> getVulnerabilitiesByReport(Integer reportId) {
        logger.info("Fetching vulnerabilities for report ID: " + reportId);
        HttpHeaders headers = generateHeaders();
        HttpEntity<String> entity = new HttpEntity<>(headers);

        VulnerabilityDTO[] vulnerabilities = restTemplate.exchange(
                backendUrl + "/report/" + reportId,
                HttpMethod.GET,
                entity,
                VulnerabilityDTO[].class
        ).getBody();

        return List.of(vulnerabilities);
    }

    @Override
    public void updateVulnerabilityStatus(Integer vulnerabilityId, Status status) {
        logger.info("Updating status for vulnerability ID: " + vulnerabilityId + " to status: " + status);
        restTemplate.put(
                backendUrl + "/" + vulnerabilityId + "/status/" + status.name(),
                null
        );
    }

    @Override
    public void deleteVulnerability(Integer vulnerabilityId) {
        logger.info("Deleting vulnerability with ID: " + vulnerabilityId);
        restTemplate.delete(backendUrl + "/" + vulnerabilityId);
    }

    @Override
    public List<VulnerabilityDTO> getAllVulnerabilities() {
        logger.info("Fetching all vulnerabilities");
        HttpHeaders headers = generateHeaders();
        HttpEntity<String> entity = new HttpEntity<>(headers);

        VulnerabilityDTO[] vulnerabilities = restTemplate.exchange(
                backendUrl,
                HttpMethod.GET,
                entity,
                VulnerabilityDTO[].class
        ).getBody();

        return List.of(vulnerabilities);
    }

    private HttpHeaders generateHeaders() {
        HttpHeaders headers = new HttpHeaders();
        headers.add(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE);
        headers.add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);
        return headers;
    }
}
